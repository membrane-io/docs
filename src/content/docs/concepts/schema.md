---
title: Schema
---

A Membrane program's graph is defined by its _schema_, autogenerated in `<your-program>/memconfig.json` based on the schema you configure in the Navigator panel.

The schema is a set of types that represent nodes in the program's graph. Nodes can be _fields_, _actions_, or _events_.

- **Fields**: queryable nodes and values
- **Actions**: invocable functions on a node
- **Events**: subscribable notifications

<video src="/cloud-assets/schema.mp4" muted autoplay controls></video>

## Root Type

Schemas must include a `Root` type which defines the type of the program's _root
node_. This node serves as the entry point into the programâ€”all references are relative to the root node.

Nodes are referred to by the program's name followed by a colon and then a path to the node from the `Root` type. For example:

- `github:` refers to the root node of the <a href="https://membrane.io/share/membrane/github" target="_blank">github driver</a>
- `twitter:` refers to the root node of the <a href="https://membrane.io/share/membrane/twitter" target="_blank">twitter driver</a>
- `github:users.one(name:"membrane-io")` refers to a Github `User`
- `github:users.one(name:"membrane-io").repos.one(name:"directory")` refers to a `Repository`

## Fields

Fields are queryable nodes that hold values you can read. From the <a href="https://membrane.io/share/membrane/github" target="_blank">github driver</a>:

- `github:status` is a field of type `String` via the `status` field on the `Root` type
- `github:users` is a field of type `UserCollection` via the `users` field on the `Root` type
- `github:users.one(name:"membrane-io")` refers to a node of type `User`
- `github:users.one(name:"juancampa")` refers to _another_ node of type `User`

The two last examples show that parameters can be passed to fields where each combination of parameters
represent a different node in the graph.

We call these references _handles_ or _grefs_ (short for graph reference).

## Actions

Actions are functions that can be invoked in the context of a graph node. Note that since actions are graph nodes too, they can be passed around and referenced just like fields.

## Events

Any Membrane program can emit events and subscribe to events.

For example, if you have a program that handles GitHub webhooks, your program could emit a `ghWebhookReceived` event, and another program that forwards GitHub notifications to Slack could subscribe to that event.

### Emitting an event

```ts twoslash
// @module: esnext
// @filename: membrane.d.ts
declare module "membrane" {
  namespace resolvers {
    export interface Root {
      endpoint(req: {
        method:
          | "GET"
          | "POST"
          | "PUT"
          | "PATCH"
          | "DELETE"
          | "HEAD"
          | "OPTIONS";
        path: string;
        body?: string;
        query?: string;
        headers: string;
      }): string;
    }
  }
  /**
   * A gref to the root of this program.
   */
  export const root: Root;
}

// ---cut---
import type { root } from "membrane";

export const endpoint: resolvers.Root["endpoint"] = (req) => {
  switch (`${req.method} ${req.path}`) {
    case "POST /gh-webhook-path":
      root.ghWebhookReceived.$emit();
    //                      ^^^^^^^^
    /* ... */
  }
};
```

### Subscribing to an event

Programs can subscribe an action to handle an event. When an event is emitted, the action will be invoked with an additional parameter called `event`.

```ts twoslash
// @module: esnext
// @filename: membrane.d.ts
type State = import("./index").State;
declare module "membrane" {
  /**
   * This object is automatically persisted by Membrane.
   * Its type is defined by the exported `State` interface
   * below.
   */
  export const state: State;
}

// ---cut---
import type { nodes } from "membrane";

export async function sendToSlack(_, { event }) {
  await nodes.slack.channel(/* ... */).sendMessage(/* ... */);
}

export async function configure() {
  nodes.ghWebhookReceived.$subscribe(sendToSlack);
  //                     ^^^^^^^^^^^^^^^^^^^^^^^^
}
```
