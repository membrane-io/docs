/// <reference no-default-lib="true"/>
/// <reference lib="es2020" />
/// <reference path="../membrane_core.d.ts" />
// This file was automatically generated by the Membrane TypeScript plugin.
// It contains typescript type definitions specific for this program.
// Do not edit manually.
type State = {
  count: number;
};
declare namespace values {
  interface Root {
    status?: string;
  }
}
declare namespace handles {
  interface Root extends Field<values.Root> {
    status: Scalar<string> & (() => Scalar<string>);
    gref: Scalar<Root> & (() => Scalar<Root>);
    increment: Action<void> & (() => Action<void>);
    statusChanged: NodeEvent<void> & (() => NodeEvent<void>);
  }
}
/**
 * Types for the objects exported from a Membrane program that define how fields, actions, and events are resolved.
 */
declare namespace resolvers {
  type Root = Partial<{
    status(
      args: {},
      options: {
        self: handles.Root;
        /** Value that is passed by the parent resolver */
        obj: Record<string, any>;
        info: {
          fieldNodes: {
            selectionSet: {
              selections: any;
            };
          }[];
        };
        context: Record<string, any>;
      },
    ): unknown;
    gref(
      args: {},
      options: {
        self: handles.Root;
        /** Value that is passed by the parent resolver */
        obj: Record<string, any>;
        info: {
          fieldNodes: {
            selectionSet: {
              selections: any;
            };
          }[];
        };
        context: Record<string, any>;
      },
    ): unknown;
    increment(
      args: {},
      options: {
        self: handles.Root;
      },
    ): unknown;
    email(
      args: {
        id: string;
        to: string;
        from?: string;
        cc?: string;
        subject: string;
        html: string;
        text: string;
        replyText?: string;
        replyTo?: string;
        inReplyTo?: string;
        attachments?: Json;
      },
      options: {
        self: handles.Root;
      },
    ): unknown;
    endpoint(
      args: {
        method: string;
        path: string;
        body?: string;
        query?: string;
        headers: string;
      },
      options: {
        self: handles.Root;
      },
    ): unknown;
    statusChanged: {
      subscribe(args: {}, options: { self: handles.Root }): unknown;
      unsubscribe(args: {}, options: { self: handles.Root }): unknown;
    };
  }>;
}
import Root = handles.Root;

declare namespace email {
  namespace values {
    interface Root {
      gref?: handles.Root;
    }

    interface PascalCase {
      field2?: string;
      gref?: handles.PascalCase;
    }

    interface Some {
      field?: Json;
      gref?: handles.Some;
    }
  }
  namespace handles {
    interface Root extends Field<values.Root> {
      /**
       * A reference to this node
       */
      gref: Scalar<Root> & (() => Scalar<Root>);
      /**
       * Sends an email to the configured address
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      send: Action<void> &
        ((args: { subject: string; body: string }) => Action<void>);
      /**
       * Invoked when an HTTP request is received for this program
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      endpoint: Action<string> &
        ((args: {
          method: string;
          path: string;
          body?: string;
          query?: string;
          headers: string;
        }) => Action<string>);
      /**
       * Invoked when a new email arrives for this program
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      email: Action<string> &
        ((args: {
          replyTo?: string;
          text: string;
          from: string;
          to: string;
          cc?: string;
          subject: string;
          html: string;
          id: string;
          inReplyTo?: string;
          replyText?: string;
          attachments?: Json;
        }) => Action<string>);
    }
    interface PascalCase extends Field<values.PascalCase> {
      field2: Scalar<string> & (() => Scalar<string>);
      /**
       * A reference to this node
       */
      gref: Scalar<PascalCase> & (() => Scalar<PascalCase>);
    }
    interface Some extends Field<values.Some> {
      field: Scalar<Json> & ((args: { bye: number }) => Scalar<Json>);
      /**
       * A reference to this node
       */
      gref: Scalar<Some> & (() => Scalar<Some>);
      action1: Action<number> & (() => Action<number>);
      action: Action<boolean> & (() => Action<boolean>);
      action2: Action<string> & (() => Action<string>);
    }
  }

  type Root = handles.Root;
  type PascalCase = handles.PascalCase;
  type Some = handles.Some;
}
declare module "membrane" {
  /**
   * Contains the graph references (grefs) that this program has been given access to.
   */
  export const nodes: {
    readonly email: email.Root;
    readonly clock: Clock;
    readonly process: Process;
  };
  /**
   * A gref to the root of this program.
   */
  export const root: Root;
  /**
   * An object that can hold any data which transparently persists across program updates.
   * To give this object a type, export a type named `State` from your program's index.ts.
   * For example:
   * ```
   *   export type State = {
   *     birthdays: Record<string, Date>;
   *   }
   * ```
   * In Membrane you can use `state` to efficiently store any object that persist across
   * invocations and updates.
   *
   * Data stored in `state` doesn't necessarily have to be serializable, any JavaScript value can be kept in it,
   * including functions, promises, dates, etc.
   */
  export const state: State;
}
