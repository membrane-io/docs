/// <reference no-default-lib="true"/>
/// <reference lib="es2020" />
/// <reference path="../membrane_core.d.ts" />
// This file was automatically generated by the Membrane TypeScript plugin.
// It contains typescript type definitions specific for this program.
// Do not edit manually.
import Root = handles.Root;
type State = {
  subscription: number;
};
declare namespace values {
  interface Root {}
}
declare namespace handles {
  interface Root extends Field<values.Root> {
    gref: Scalar<Root> & (() => Scalar<Root>);
    run: Action<void> & (() => Action<void>);
    handleIssueOpened: Action<void> & (() => Action<void>);
  }
}
/**
 * Types for the objects exported from a Membrane program that define how fields, actions, and events are resolved.
 */
declare namespace resolvers {
  type Root = Partial<{
    gref(
      args: {},
      options: {
        self: handles.Root;
        /** Value that is passed by the parent resolver */
        obj: Record<string, any>;
        info: {
          fieldNodes: {
            selectionSet: {
              selections: any;
            };
          }[];
        };
        context: Record<string, any>;
      }
    ): unknown;
    run(
      args: {},
      options: {
        self: handles.Root;
      }
    ): unknown;
    handleIssueOpened(
      args: {},
      options: {
        self: handles.Root;
      }
    ): unknown;
    email(
      args: {
        id: string;
        to: string;
        from?: string;
        cc?: string;
        subject: string;
        html: string;
        text: string;
        replyText?: string;
        replyTo?: string;
        inReplyTo?: string;
        attachments?: Json;
      },
      options: {
        self: handles.Root;
      }
    ): unknown;
    endpoint(
      args: {
        method: string;
        path: string;
        body?: string;
        query?: string;
        headers: string;
      },
      options: {
        self: handles.Root;
      }
    ): unknown;
  }>;
}

declare namespace github {
  namespace values {
    interface Root {
      status?: string;
      users?: UserCollection;
      organizations?: OrganizationCollection;
      search?: GlobalSearch;
      parse?: handles.Repository[];
      tests?: Tests;
      gref?: handles.Root;
    }

    interface UserCollection {
      one?: User;
      page?: UserPage;
      gref?: handles.UserCollection;
    }

    interface UserPage {
      items?: User[];
      next?: handles.UserPage;
      gref?: handles.UserPage;
    }

    interface User {
      login?: string;
      name?: string;
      bio?: string;
      blog?: string;
      company?: string;
      repos?: RepositoryCollection;
      email?: string;
      id?: number;
      followers?: number;
      following?: number;
      location?: string;
      type?: string;
      avatar_url?: string;
      created_at?: string;
      gravatar_id?: string;
      public_gists?: number;
      public_repos?: number;
      site_admin?: boolean;
      hireable?: boolean;
      updated_at?: string;
      gref?: handles.User;
    }

    interface OrganizationCollection {
      one?: Organization;
      page?: OrganizationPage;
      gref?: handles.OrganizationCollection;
    }

    interface OrganizationPage {
      items?: Organization[];
      next?: handles.OrganizationPage;
      gref?: handles.OrganizationPage;
    }

    interface Organization {
      repos?: RepositoryCollection;
      login?: string;
      id?: number;
      node_id?: string;
      html_url?: string;
      url?: string;
      description?: string;
      name?: string;
      company?: string;
      blog?: string;
      location?: string;
      email?: string;
      is_verified?: boolean;
      followers?: number;
      following?: number;
      created_at?: string;
      updated_at?: string;
      gref?: handles.Organization;
    }

    interface RepositoryCollection {
      one?: Repository;
      page?: RepositoryPage;
      search?: RepositoryPage;
      gref?: handles.RepositoryCollection;
    }

    interface RepositoryPage {
      items?: Repository[];
      next?: handles.RepositoryPage;
      gref?: handles.RepositoryPage;
    }

    interface Repository {
      name?: string;
      description?: string;
      content?: ContentCollection;
      archived?: boolean;
      branches?: BranchCollection;
      fork?: boolean;
      homepage?: string;
      id?: number;
      language?: string;
      private?: boolean;
      size?: number;
      url?: string;
      allow_merge_commit?: boolean;
      allow_rebase_merge?: boolean;
      allow_squash_merge?: boolean;
      created_at?: string;
      default_branch?: string;
      forks_count?: number;
      full_name?: string;
      has_downloads?: boolean;
      has_issues?: boolean;
      has_pages?: boolean;
      has_wiki?: boolean;
      html_url?: string;
      issues?: IssueCollection;
      network_count?: number;
      open_issues_count?: number;
      pushed_at?: string;
      stargazers_count?: number;
      subscribers_count?: number;
      updated_at?: string;
      watchers_count?: number;
      pull_requests?: PullRequestCollection;
      releases?: ReleaseCollection;
      license?: License;
      commits?: CommitCollection;
      gref?: handles.Repository;
    }

    interface PushEvent {
      commit?: handles.Commit;
      gref?: handles.PushEvent;
    }

    interface License {
      name?: string;
      path?: string;
      sha?: string;
      size?: number;
      url?: string;
      type?: string;
      content?: string;
      encoding?: string;
      license?: LicenseDesc;
      html_url?: string;
      git_url?: string;
      download_url?: string;
      gref?: handles.License;
    }

    interface LicenseDesc {
      key?: string;
      name?: string;
      url?: string;
      spdx_id?: string;
      gref?: handles.LicenseDesc;
    }

    interface BranchCollection {
      one?: Branch;
      page?: BranchPage;
      gref?: handles.BranchCollection;
    }

    interface BranchPage {
      items?: Branch[];
      next?: handles.BranchPage;
      gref?: handles.BranchPage;
    }

    interface Branch {
      name?: string;
      commit?: Commit;
      protected?: boolean;
      gref?: handles.Branch;
    }

    interface CommitCollection {
      one?: Commit;
      page?: CommitPage;
      gref?: handles.CommitCollection;
    }

    interface CommitPage {
      items?: Commit[];
      next?: handles.CommitPage;
      gref?: handles.CommitPage;
    }

    interface Commit {
      sha?: string;
      message?: string;
      author?: string;
      html_url?: string;
      date?: string;
      gref?: handles.Commit;
    }

    interface Reactions {
      total_count?: number;
      plus_1?: number;
      minus_1?: number;
      laugh?: number;
      hooray?: number;
      confused?: number;
      heart?: number;
      rocket?: number;
      eyes?: number;
      gref?: handles.Reactions;
    }

    interface IssueCollection {
      one?: Issue;
      search?: IssueSearchPage;
      page?: IssuePage;
      gref?: handles.IssueCollection;
    }

    interface IssueSearchPage {
      total_count?: number;
      incomplete_results?: boolean;
      next?: handles.IssueSearchPage;
      items?: Issue[];
      gref?: handles.IssueSearchPage;
    }

    interface IssuePage {
      items?: Issue[];
      next?: handles.IssuePage;
      gref?: handles.IssuePage;
    }

    interface Issue {
      active_lock_reason?: string;
      assignee?: User;
      assignees?: User[];
      author_association?: string;
      body?: string;
      closed_at?: string;
      closed_by?: User;
      comments?: CommentCollection;
      created_at?: string;
      draft?: boolean;
      id?: number;
      labels?: Label[];
      locked?: boolean;
      milestone?: string;
      node_id?: string;
      number?: number;
      pull_request?: PullRequest;
      reactions?: Reactions;
      state?: string;
      title?: string;
      updated_at?: string;
      url?: string;
      user?: User;
      html_url?: string;
      view?: Json;
      gref?: handles.Issue;
    }

    interface IssueEvent {
      issue?: handles.Issue;
      gref?: handles.IssueEvent;
    }

    interface Label {
      name?: string;
      node_id?: string;
      id?: number;
      color?: string;
      description?: string;
      default?: boolean;
      gref?: handles.Label;
    }

    interface PullRequestCollection {
      one?: PullRequest;
      page?: PullRequestPage;
      gref?: handles.PullRequestCollection;
    }

    interface PullRequestPage {
      items?: PullRequest[];
      next?: handles.PullRequestPage;
      gref?: handles.PullRequestPage;
    }

    interface PullRequest {
      number?: number;
      title?: string;
      id?: number;
      state?: string;
      body?: string;
      locked?: boolean;
      merged?: boolean;
      active_lock_reason?: string;
      diff?: string;
      node_id?: string;
      owner?: handles.User;
      comments?: CommentCollection;
      html_url?: string;
      url?: string;
      pull_request_reviews?: PullRequestReviewCollection;
      requested_reviewers?: RequestedReviewers;
      gref?: handles.PullRequest;
    }

    interface PullRequestEvent {
      pullRequest?: handles.PullRequest;
      gref?: handles.PullRequestEvent;
    }

    interface PullRequestReviewCollection {
      one?: PullRequestReview;
      page?: PullRequestReviewPage;
      gref?: handles.PullRequestReviewCollection;
    }

    interface PullRequestReviewPage {
      items?: PullRequestReview[];
      next?: handles.PullRequestReviewPage;
      gref?: handles.PullRequestReviewPage;
    }

    interface PullRequestReview {
      author_association?: string;
      body?: string;
      commit_id?: string;
      html_url?: string;
      id?: number;
      node_id?: string;
      pull_request_url?: string;
      state?: string;
      submitted_at?: string;
      user?: handles.User;
      gref?: handles.PullRequestReview;
    }

    interface PullRequestReviewEvent {
      pullRequestReview?: handles.PullRequestReview;
      gref?: handles.PullRequestReviewEvent;
    }

    interface RequestedReviewers {
      one?: ReviewRequest;
      page?: ReviewRequestsPage;
      gref?: handles.RequestedReviewers;
    }

    interface ReviewRequestsPage {
      items?: ReviewRequest[];
      next?: handles.ReviewRequestsPage;
      gref?: handles.ReviewRequestsPage;
    }

    interface ReviewRequest {
      user?: handles.User;
      time?: string;
      gref?: handles.ReviewRequest;
    }

    interface ReviewRequestEvent {
      pullRequest?: handles.PullRequest;
      requestedReviewer?: handles.User;
      requester?: handles.User;
      gref?: handles.ReviewRequestEvent;
    }

    interface CommentCollection {
      one?: Comment;
      page?: CommentPage;
      gref?: handles.CommentCollection;
    }

    interface CommentPage {
      items?: Comment[];
      next?: handles.CommentPage;
      gref?: handles.CommentPage;
    }

    interface Comment {
      id?: number;
      body?: string;
      created_at?: string;
      updated_at?: string;
      user?: User;
      html_url?: string;
      url?: string;
      issue_url?: string;
      node_id?: string;
      author_association?: string;
      reactions?: Reactions;
      performed_via_github_app?: string;
      gref?: handles.Comment;
    }

    interface CommentEvent {
      comment?: handles.Comment;
      gref?: handles.CommentEvent;
    }

    interface ReleaseCollection {
      one?: Release;
      page?: ReleasePage;
      gref?: handles.ReleaseCollection;
    }

    interface ReleasePage {
      items?: Release[];
      next?: handles.ReleasePage;
      gref?: handles.ReleasePage;
    }

    interface Release {
      id?: number;
      name?: string;
      body?: string;
      draft?: boolean;
      prerelease?: boolean;
      html_url?: string;
      url?: string;
      node_id?: string;
      tag_name?: string;
      target_commitish?: string;
      created_at?: string;
      gref?: handles.Release;
    }

    interface ReleaseEvent {
      release?: handles.Release;
      gref?: handles.ReleaseEvent;
    }

    interface ContentCollection {
      file?: Content;
      dir?: Content[];
      gref?: handles.ContentCollection;
    }

    interface Content {
      type?: string;
      name?: string;
      encoding?: string;
      content?: string;
      contentText?: string;
      path?: string;
      sha?: string;
      size?: number;
      submodule_git_url?: string;
      html_url?: string;
      download_url?: string;
      gref?: handles.Content;
    }

    interface GlobalSearch {
      commits?: CommitPage;
      issues?: IssuePage;
      repos?: RepositoryPage;
      gref?: handles.GlobalSearch;
    }

    interface Tests {
      gref?: handles.Tests;
    }
  }
  namespace handles {
    interface Root extends Field<values.Root> {
      /**
       * Indicates whether this github program is configured and ready
       */
      status: Scalar<string> & (() => Scalar<string>);
      /**
       * Collection of Github users
       */
      users: UserCollection & (() => UserCollection);
      /**
       * Collection of Github orgs
       */
      organizations: OrganizationCollection & (() => OrganizationCollection);
      /**
       * Global search functionality
       */
      search: GlobalSearch & (() => GlobalSearch);
      /**
       * List of repositories with name and value filters
       */
      parse: ListField<handles.Repository> &
        ((args: {
          name: string;
          value: string;
        }) => ListField<handles.Repository>);
      /**
       * Tests
       */
      tests: Tests & (() => Tests);
      /**
       * A reference to this node
       */
      gref: Scalar<Root> & (() => Scalar<Root>);
      /**
       * Invoke with a valid Github access token to configure this program
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      configure: Action<void> & ((args: { token: string }) => Action<void>);
      /**
       * Invoke an HTTP endpoint with the specified method, body, path, query, and headers
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      endpoint: Action<string> &
        ((args: {
          method: string;
          body?: string;
          path: string;
          query?: string;
          headers: string;
        }) => Action<string>);
      /**
       * Invoked when a new email arrives for this program
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      email: Action<string> &
        ((args: {
          replyTo?: string;
          text: string;
          from: string;
          to: string;
          cc?: string;
          subject: string;
          html: string;
          id: string;
          inReplyTo?: string;
          replyText?: string;
          attachments?: Json;
        }) => Action<string>);
      /**
       * Triggered when the status of the Github API program changes
       */
      statusChanged: NodeEvent<void> & (() => NodeEvent<void>);
    }
    interface UserCollection extends Field<values.UserCollection> {
      /**
       * Field representing a single Github user
       */
      one: User & ((args: { name: string }) => User);
      /**
       * Field representing a page of Github users
       */
      page: UserPage & ((args?: { since?: string }) => UserPage);
      /**
       * A reference to this node
       */
      gref: Scalar<UserCollection> & (() => Scalar<UserCollection>);
    }
    interface UserPage extends Field<values.UserPage> {
      /**
       * List of Github user items
       */
      items: ListField<values.User> & (() => ListField<values.User>);
      /**
       * Reference to the next page of Github user items
       */
      next: Scalar<UserPage> & (() => Scalar<UserPage>);
      /**
       * A reference to this node
       */
      gref: Scalar<UserPage> & (() => Scalar<UserPage>);
    }
    interface User extends Field<values.User> {
      /**
       * The user's login name
       */
      login: Scalar<string> & (() => Scalar<string>);
      /**
       * The user's name
       */
      name: Scalar<string> & (() => Scalar<string>);
      /**
       * The user's bio
       */
      bio: Scalar<string> & (() => Scalar<string>);
      /**
       * The user's blog
       */
      blog: Scalar<string> & (() => Scalar<string>);
      /**
       * The user's company
       */
      company: Scalar<string> & (() => Scalar<string>);
      /**
       * Collection of Github repositories owned by the user
       */
      repos: RepositoryCollection & (() => RepositoryCollection);
      /**
       * The user's email address
       */
      email: Scalar<string> & (() => Scalar<string>);
      /**
       * The user's ID
       */
      id: Scalar<number> & (() => Scalar<number>);
      /**
       * The number of followers the user has
       */
      followers: Scalar<number> & (() => Scalar<number>);
      /**
       * The number of users the user is following
       */
      following: Scalar<number> & (() => Scalar<number>);
      /**
       * The user's location
       */
      location: Scalar<string> & (() => Scalar<string>);
      /**
       * The type of user
       */
      type: Scalar<string> & (() => Scalar<string>);
      /**
       * The URL of the user's avatar
       */
      avatar_url: Scalar<string> &
        ((args?: { size?: number }) => Scalar<string>);
      /**
       * The date the user account was created
       */
      created_at: Scalar<string> & (() => Scalar<string>);
      /**
       * The user's gravatar ID
       */
      gravatar_id: Scalar<string> & (() => Scalar<string>);
      /**
       * The number of public gists the user has
       */
      public_gists: Scalar<number> & (() => Scalar<number>);
      /**
       * The number of public repositories the user has
       */
      public_repos: Scalar<number> & (() => Scalar<number>);
      /**
       * Indicates if the user is a site admin
       */
      site_admin: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * Indicates if the user is available for hire
       */
      hireable: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * The date the user account was last updated
       */
      updated_at: Scalar<string> & (() => Scalar<string>);
      /**
       * A reference to this node
       */
      gref: Scalar<User> & (() => Scalar<User>);
    }
    interface OrganizationCollection
      extends Field<values.OrganizationCollection> {
      one: Organization & ((args: { name: string }) => Organization);
      page: OrganizationPage &
        ((args?: { since?: string }) => OrganizationPage);
      /**
       * A reference to this node
       */
      gref: Scalar<OrganizationCollection> &
        (() => Scalar<OrganizationCollection>);
    }
    interface OrganizationPage extends Field<values.OrganizationPage> {
      items: ListField<values.Organization> &
        (() => ListField<values.Organization>);
      next: Scalar<OrganizationPage> & (() => Scalar<OrganizationPage>);
      /**
       * A reference to this node
       */
      gref: Scalar<OrganizationPage> & (() => Scalar<OrganizationPage>);
    }
    interface Organization extends Field<values.Organization> {
      /**
       * The organization's repositories.
       */
      repos: RepositoryCollection & (() => RepositoryCollection);
      /**
       * The organization's login username.
       */
      login: Scalar<string> & (() => Scalar<string>);
      /**
       * The unique identifier of the organization.
       */
      id: Scalar<number> & (() => Scalar<number>);
      /**
       * The node identifier for the organization.
       */
      node_id: Scalar<string> & (() => Scalar<string>);
      /**
       * The github.com URL for the organization.
       */
      html_url: Scalar<string> & (() => Scalar<string>);
      /**
       * The API URL for the organization.
       */
      url: Scalar<string> & (() => Scalar<string>);
      /**
       * The description or bio of the organization.
       */
      description: Scalar<string> & (() => Scalar<string>);
      /**
       * The organization's name.
       */
      name: Scalar<string> & (() => Scalar<string>);
      /**
       * The organizationâ€™s company name or affiliation.
       */
      company: Scalar<string> & (() => Scalar<string>);
      /**
       * The URL to the organization's blog or website.
       */
      blog: Scalar<string> & (() => Scalar<string>);
      /**
       * The organization's location.
       */
      location: Scalar<string> & (() => Scalar<string>);
      /**
       * The organization's public email address.
       */
      email: Scalar<string> & (() => Scalar<string>);
      /**
       * Whether the organization is verified by GitHub.
       */
      is_verified: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * The number of users following the organization.
       */
      followers: Scalar<number> & (() => Scalar<number>);
      /**
       * The number of users the organization is following.
       */
      following: Scalar<number> & (() => Scalar<number>);
      /**
       * The creation date of the organization.
       */
      created_at: Scalar<string> & (() => Scalar<string>);
      /**
       * The date when the organization's information was last updated.
       */
      updated_at: Scalar<string> & (() => Scalar<string>);
      /**
       * A reference to this node
       */
      gref: Scalar<Organization> & (() => Scalar<Organization>);
      commentCreated: NodeEvent<values.CommentEvent> &
        (() => NodeEvent<values.CommentEvent>);
      reviewRequested: NodeEvent<values.ReviewRequestEvent> &
        (() => NodeEvent<values.ReviewRequestEvent>);
      reviewCreated: NodeEvent<values.PullRequestReviewEvent> &
        (() => NodeEvent<values.PullRequestReviewEvent>);
    }
    interface RepositoryCollection extends Field<values.RepositoryCollection> {
      /**
       * Retrieve a single repository by name
       */
      one: Repository & ((args: { name: string }) => Repository);
      /**
       * Retrieve a page of repositories with optional filtering and pagination
       */
      page: RepositoryPage &
        ((args?: {
          type?: string;
          sort?: string;
          direction?: string;
          page?: number;
          pageSize?: number;
        }) => RepositoryPage);
      /**
       * Search for repositories with optional filtering and pagination
       */
      search: RepositoryPage &
        ((args?: {
          q?: string;
          sort?: string;
          order?: string;
          page?: number;
          pageSize?: number;
        }) => RepositoryPage);
      /**
       * A reference to this node
       */
      gref: Scalar<RepositoryCollection> & (() => Scalar<RepositoryCollection>);
    }
    interface RepositoryPage extends Field<values.RepositoryPage> {
      /**
       * List of repositories in the page
       */
      items: ListField<values.Repository> &
        (() => ListField<values.Repository>);
      /**
       * Reference to the next page of repositories
       */
      next: Scalar<RepositoryPage> & (() => Scalar<RepositoryPage>);
      /**
       * A reference to this node
       */
      gref: Scalar<RepositoryPage> & (() => Scalar<RepositoryPage>);
    }
    interface Repository extends Field<values.Repository> {
      /**
       * The name of the repository
       */
      name: Scalar<string> & (() => Scalar<string>);
      /**
       * The description of the repository
       */
      description: Scalar<string> & (() => Scalar<string>);
      /**
       * Collection of content within the repository
       */
      content: ContentCollection & (() => ContentCollection);
      /**
       * Indicates if the repository is archived
       */
      archived: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * Collection of branches in the repository
       */
      branches: BranchCollection & (() => BranchCollection);
      /**
       * Indicates if the repository is a fork
       */
      fork: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * The URL of the repository's homepage
       */
      homepage: Scalar<string> & (() => Scalar<string>);
      /**
       * The unique identifier of the repository
       */
      id: Scalar<number> & (() => Scalar<number>);
      /**
       * The primary programming language of the repository
       */
      language: Scalar<string> & (() => Scalar<string>);
      /**
       * Indicates if the repository is private
       */
      private: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * The size of the repository in kilobytes
       */
      size: Scalar<number> & (() => Scalar<number>);
      /**
       * The URL of the repository
       */
      url: Scalar<string> & (() => Scalar<string>);
      /**
       * Indicates if merge commit is allowed
       */
      allow_merge_commit: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * Indicates if rebase merge is allowed
       */
      allow_rebase_merge: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * Indicates if squash merge is allowed
       */
      allow_squash_merge: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * The creation date of the repository
       */
      created_at: Scalar<string> & (() => Scalar<string>);
      /**
       * The default branch of the repository
       */
      default_branch: Scalar<string> & (() => Scalar<string>);
      /**
       * The number of forks of the repository
       */
      forks_count: Scalar<number> & (() => Scalar<number>);
      /**
       * The full name of the repository
       */
      full_name: Scalar<string> & (() => Scalar<string>);
      /**
       * Indicates if the repository has downloads
       */
      has_downloads: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * Indicates if the repository has issues
       */
      has_issues: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * Indicates if the repository has pages
       */
      has_pages: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * Indicates if the repository has a wiki
       */
      has_wiki: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * The HTML URL of the repository
       */
      html_url: Scalar<string> & (() => Scalar<string>);
      /**
       * Collection of issues in the repository
       */
      issues: IssueCollection & (() => IssueCollection);
      /**
       * The count of collaborators on the repository
       */
      network_count: Scalar<number> & (() => Scalar<number>);
      /**
       * The count of open issues in the repository
       */
      open_issues_count: Scalar<number> & (() => Scalar<number>);
      /**
       * The date of the latest push to the repository
       */
      pushed_at: Scalar<string> & (() => Scalar<string>);
      /**
       * The count of stargazers on the repository
       */
      stargazers_count: Scalar<number> & (() => Scalar<number>);
      /**
       * The count of subscribers to the repository
       */
      subscribers_count: Scalar<number> & (() => Scalar<number>);
      /**
       * The date of the latest update to the repository
       */
      updated_at: Scalar<string> & (() => Scalar<string>);
      /**
       * The count of watchers on the repository
       */
      watchers_count: Scalar<number> & (() => Scalar<number>);
      /**
       * Collection of pull requests in the repository
       */
      pull_requests: PullRequestCollection & (() => PullRequestCollection);
      /**
       * Collection of releases in the repository
       */
      releases: ReleaseCollection & (() => ReleaseCollection);
      /**
       * The license of the repository
       */
      license: License & (() => License);
      /**
       * Collection of commits in the repository
       */
      commits: CommitCollection & (() => CommitCollection);
      /**
       * A reference to this node
       */
      gref: Scalar<Repository> & (() => Scalar<Repository>);
      /**
       * Archive a repository
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      archive: Action<void> & (() => Action<void>);
      /**
       * Transfers the ownership of the repository to a new owner with a new name
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      transfer: Action<void> &
        ((args: { new_owner: string; new_name: string }) => Action<void>);
      /**
       * Adds a collaborator to the repository with the specified permission level
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      addCollaborator: Action<void> &
        ((args: { username: string; permission: string }) => Action<void>);
      /**
       * Creates a new tree within the repository based on the provided parameters
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      createTree: Action<string> &
        ((args: {
          base: string;
          path: string;
          tree: string;
        }) => Action<string>);
      /**
       * Creates a new file tree within the repository based on the provided parameters
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      createFileTree: Action<string> &
        ((args: {
          base: string;
          path: string;
          content: string;
        }) => Action<string>);
      createAutolink: Action<void> &
        ((args: {
          keyPrefix: string;
          urlTemplate: string;
          alphanumeric?: boolean;
        }) => Action<void>);
      /**
       * Event indicating creation of a comment within the repository
       */
      commentCreated: NodeEvent<values.CommentEvent> &
        (() => NodeEvent<values.CommentEvent>);
      /**
       * Event indicating the opening of an issue within the repository
       */
      issueOpened: NodeEvent<values.IssueEvent> &
        (() => NodeEvent<values.IssueEvent>);
      /**
       * Event indicating the opening of a pull request within the repository
       */
      pullRequestOpened: NodeEvent<values.PullRequestEvent> &
        (() => NodeEvent<values.PullRequestEvent>);
      /**
       * Event indicating the publication of a release within the repository
       */
      releasePublished: NodeEvent<values.ReleaseEvent> &
        (() => NodeEvent<values.ReleaseEvent>);
      /**
       * Event indicating a push to the repository
       */
      pushed: NodeEvent<values.PushEvent> & (() => NodeEvent<values.PushEvent>);
    }
    interface PushEvent extends Field<values.PushEvent> {
      commit: Scalar<Commit> & (() => Scalar<Commit>);
      /**
       * A reference to this node
       */
      gref: Scalar<PushEvent> & (() => Scalar<PushEvent>);
    }
    interface License extends Field<values.License> {
      /**
       * The name of the license
       */
      name: Scalar<string> & (() => Scalar<string>);
      /**
       * The path of the license
       */
      path: Scalar<string> & (() => Scalar<string>);
      /**
       * The SHA of the license
       */
      sha: Scalar<string> & (() => Scalar<string>);
      /**
       * The size of the license
       */
      size: Scalar<number> & (() => Scalar<number>);
      /**
       * The URL of the license
       */
      url: Scalar<string> & (() => Scalar<string>);
      /**
       * The type of the license
       */
      type: Scalar<string> & (() => Scalar<string>);
      /**
       * The content of the license
       */
      content: Scalar<string> & (() => Scalar<string>);
      /**
       * The encoding of the license
       */
      encoding: Scalar<string> & (() => Scalar<string>);
      /**
       * The description of the license
       */
      license: LicenseDesc & (() => LicenseDesc);
      /**
       * The HTML URL of the license
       */
      html_url: Scalar<string> & (() => Scalar<string>);
      /**
       * The Git URL of the license
       */
      git_url: Scalar<string> & (() => Scalar<string>);
      /**
       * The download URL of the license
       */
      download_url: Scalar<string> & (() => Scalar<string>);
      /**
       * A reference to this node
       */
      gref: Scalar<License> & (() => Scalar<License>);
    }
    interface LicenseDesc extends Field<values.LicenseDesc> {
      /**
       * The key of the license description
       */
      key: Scalar<string> & (() => Scalar<string>);
      /**
       * The name of the license description
       */
      name: Scalar<string> & (() => Scalar<string>);
      /**
       * The URL of the license description
       */
      url: Scalar<string> & (() => Scalar<string>);
      /**
       * The SPDX ID of the license description
       */
      spdx_id: Scalar<string> & (() => Scalar<string>);
      /**
       * A reference to this node
       */
      gref: Scalar<LicenseDesc> & (() => Scalar<LicenseDesc>);
    }
    interface BranchCollection extends Field<values.BranchCollection> {
      /**
       * Retrieve a single branch from the collection
       */
      one: Branch & ((args: { name: string }) => Branch);
      /**
       * Retrieve a page of branches from the collection
       */
      page: BranchPage &
        ((args?: { page?: number; pageSize?: number }) => BranchPage);
      /**
       * A reference to this node
       */
      gref: Scalar<BranchCollection> & (() => Scalar<BranchCollection>);
    }
    interface BranchPage extends Field<values.BranchPage> {
      /**
       * List of branches
       */
      items: ListField<values.Branch> & (() => ListField<values.Branch>);
      /**
       * Reference to the next page of branches
       */
      next: Scalar<BranchPage> & (() => Scalar<BranchPage>);
      /**
       * A reference to this node
       */
      gref: Scalar<BranchPage> & (() => Scalar<BranchPage>);
    }
    interface Branch extends Field<values.Branch> {
      /**
       * The name of the branch
       */
      name: Scalar<string> & (() => Scalar<string>);
      /**
       * The commit associated with the branch
       */
      commit: Commit & (() => Commit);
      /**
       * Indicates whether the branch is protected
       */
      protected: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * A reference to this node
       */
      gref: Scalar<Branch> & (() => Scalar<Branch>);
      /**
       * Updates the branch with the specified SHA and reference
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      update: Action<void> &
        ((args: { sha: string; ref: string }) => Action<void>);
    }
    interface CommitCollection extends Field<values.CommitCollection> {
      /**
       * Represents a single commit with the specified reference
       */
      one: Commit & ((args: { ref: string }) => Commit);
      /**
       * Represents a page of commits with optional page number and page size
       */
      page: CommitPage &
        ((args?: { page?: number; pageSize?: number }) => CommitPage);
      /**
       * A reference to this node
       */
      gref: Scalar<CommitCollection> & (() => Scalar<CommitCollection>);
      /**
       * Creates a new commit with the specified message, tree, and parents
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      create: Action<string> &
        ((args: {
          message: string;
          tree: string;
          parents: string;
        }) => Action<string>);
    }
    interface CommitPage extends Field<values.CommitPage> {
      /**
       * List of commit items.
       */
      items: ListField<values.Commit> & (() => ListField<values.Commit>);
      /**
       * Reference to the next commit page.
       */
      next: Scalar<CommitPage> & (() => Scalar<CommitPage>);
      /**
       * A reference to this node
       */
      gref: Scalar<CommitPage> & (() => Scalar<CommitPage>);
    }
    interface Commit extends Field<values.Commit> {
      /**
       * The SHA of the commit
       */
      sha: Scalar<string> & (() => Scalar<string>);
      /**
       * The commit message
       */
      message: Scalar<string> & (() => Scalar<string>);
      /**
       * The author of the commit
       */
      author: Scalar<string> & (() => Scalar<string>);
      /**
       * The HTML URL of the commit
       */
      html_url: Scalar<string> & (() => Scalar<string>);
      /**
       * The date of the commit
       */
      date: Scalar<string> & (() => Scalar<string>);
      /**
       * A reference to this node
       */
      gref: Scalar<Commit> & (() => Scalar<Commit>);
    }
    interface Reactions extends Field<values.Reactions> {
      total_count: Scalar<number> & (() => Scalar<number>);
      plus_1: Scalar<number> & (() => Scalar<number>);
      minus_1: Scalar<number> & (() => Scalar<number>);
      laugh: Scalar<number> & (() => Scalar<number>);
      hooray: Scalar<number> & (() => Scalar<number>);
      confused: Scalar<number> & (() => Scalar<number>);
      heart: Scalar<number> & (() => Scalar<number>);
      rocket: Scalar<number> & (() => Scalar<number>);
      eyes: Scalar<number> & (() => Scalar<number>);
      /**
       * A reference to this node
       */
      gref: Scalar<Reactions> & (() => Scalar<Reactions>);
    }
    interface IssueCollection extends Field<values.IssueCollection> {
      /**
       * Get a single issue by its number
       */
      one: Issue & ((args: { number: number }) => Issue);
      /**
       * Search for issues based on specified criteria
       */
      search: IssueSearchPage &
        ((args?: {
          page?: number;
          pageSize?: number;
          q?: string;
          sort?: string;
          order?: string;
        }) => IssueSearchPage);
      /**
       * Retrieve a page of issues based on specified criteria
       */
      page: IssuePage &
        ((args?: {
          page?: number;
          pageSize?: number;
          kind?: string;
          milestone?: string;
          state?: string;
          assignee?: string;
          creator?: string;
          mentioned?: string;
          labels?: string;
          sort?: string;
          direction?: string;
          since?: string;
        }) => IssuePage);
      /**
       * A reference to this node
       */
      gref: Scalar<IssueCollection> & (() => Scalar<IssueCollection>);
    }
    interface IssueSearchPage extends Field<values.IssueSearchPage> {
      total_count: Scalar<number> & (() => Scalar<number>);
      incomplete_results: Scalar<boolean> & (() => Scalar<boolean>);
      next: Scalar<IssueSearchPage> & (() => Scalar<IssueSearchPage>);
      items: ListField<values.Issue> & (() => ListField<values.Issue>);
      /**
       * A reference to this node
       */
      gref: Scalar<IssueSearchPage> & (() => Scalar<IssueSearchPage>);
    }
    interface IssuePage extends Field<values.IssuePage> {
      /**
       * List of issues in the current page.
       */
      items: ListField<values.Issue> & (() => ListField<values.Issue>);
      /**
       * Reference to the next page of issues.
       */
      next: Scalar<IssuePage> & (() => Scalar<IssuePage>);
      /**
       * A reference to this node
       */
      gref: Scalar<IssuePage> & (() => Scalar<IssuePage>);
    }
    interface Issue extends Field<values.Issue> {
      /**
       * The reason for the active lock on the issue
       */
      active_lock_reason: Scalar<string> & (() => Scalar<string>);
      /**
       * The user assigned to the issue
       */
      assignee: User & (() => User);
      /**
       * The list of users assigned to the issue
       */
      assignees: ListField<values.User> & (() => ListField<values.User>);
      /**
       * The association of the author with the issue
       */
      author_association: Scalar<string> & (() => Scalar<string>);
      /**
       * The body of the issue
       */
      body: Scalar<string> & (() => Scalar<string>);
      /**
       * The date and time when the issue was closed
       */
      closed_at: Scalar<string> & (() => Scalar<string>);
      /**
       * The user who closed the issue
       */
      closed_by: User & (() => User);
      /**
       * Collection of comments on the issue
       */
      comments: CommentCollection & (() => CommentCollection);
      /**
       * The date and time when the issue was created
       */
      created_at: Scalar<string> & (() => Scalar<string>);
      /**
       * Indicates if the issue is a draft
       */
      draft: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * The unique identifier of the issue
       */
      id: Scalar<number> & (() => Scalar<number>);
      /**
       * The list of labels associated with the issue
       */
      labels: ListField<values.Label> & (() => ListField<values.Label>);
      /**
       * Indicates if the issue is locked
       */
      locked: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * The milestone associated with the issue
       */
      milestone: Scalar<string> & (() => Scalar<string>);
      /**
       * The node ID of the issue
       */
      node_id: Scalar<string> & (() => Scalar<string>);
      /**
       * The issue number
       */
      number: Scalar<number> & (() => Scalar<number>);
      /**
       * The pull request associated with the issue
       */
      pull_request: PullRequest & (() => PullRequest);
      /**
       * Reactions associated with the issue
       */
      reactions: Reactions & (() => Reactions);
      /**
       * The state of the issue
       */
      state: Scalar<string> & (() => Scalar<string>);
      /**
       * The title of the issue
       */
      title: Scalar<string> & (() => Scalar<string>);
      /**
       * The date and time when the issue was last updated
       */
      updated_at: Scalar<string> & (() => Scalar<string>);
      /**
       * The URL of the issue
       */
      url: Scalar<string> & (() => Scalar<string>);
      /**
       * The user who created the issue
       */
      user: User & (() => User);
      /**
       * The HTML URL of the issue
       */
      html_url: Scalar<string> & (() => Scalar<string>);
      view: Scalar<Json> & (() => Scalar<Json>);
      /**
       * A reference to this node
       */
      gref: Scalar<Issue> & (() => Scalar<Issue>);
      patch: Action<void> &
        ((args?: {
          title?: string;
          body?: string;
          state?: string;
          assignee?: string;
          state_reason?: string;
          milestone?: string;
          labels?: Json;
          assignees?: Json;
        }) => Action<void>);
      /**
       * Close the issue
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      close: Action<void> & (() => Action<void>);
      /**
       * Create a new comment on the issue
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      createComment: Action<void> & ((args: { body: string }) => Action<void>);
      /**
       * Triggered when a new comment is created on the issue
       */
      commentCreated: NodeEvent<values.CommentEvent> &
        (() => NodeEvent<values.CommentEvent>);
      /**
       * Triggered when the issue is closed
       */
      closed: NodeEvent<boolean> & (() => NodeEvent<boolean>);
    }
    interface IssueEvent extends Field<values.IssueEvent> {
      /**
       * Reference to the issue related to the event.
       */
      issue: Scalar<Issue> & (() => Scalar<Issue>);
      /**
       * A reference to this node
       */
      gref: Scalar<IssueEvent> & (() => Scalar<IssueEvent>);
    }
    interface Label extends Field<values.Label> {
      /**
       * Field representing the name of the label
       */
      name: Scalar<string> & (() => Scalar<string>);
      /**
       * Field representing the node ID of the label
       */
      node_id: Scalar<string> & (() => Scalar<string>);
      /**
       * Field representing the ID of the label
       */
      id: Scalar<number> & (() => Scalar<number>);
      /**
       * Field representing the color of the label
       */
      color: Scalar<string> & (() => Scalar<string>);
      /**
       * Field representing the description of the label
       */
      description: Scalar<string> & (() => Scalar<string>);
      /**
       * Field representing the default status of the label
       */
      default: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * A reference to this node
       */
      gref: Scalar<Label> & (() => Scalar<Label>);
    }
    interface PullRequestCollection
      extends Field<values.PullRequestCollection> {
      /**
       * Retrieve a single pull request
       */
      one: PullRequest & ((args: { number: number }) => PullRequest);
      /**
       * Retrieve a page of pull requests
       */
      page: PullRequestPage &
        ((args?: {
          state?: string;
          head?: string;
          base?: string;
          sort?: string;
          order?: string;
          page?: number;
          pageSize?: number;
        }) => PullRequestPage);
      /**
       * A reference to this node
       */
      gref: Scalar<PullRequestCollection> &
        (() => Scalar<PullRequestCollection>);
    }
    interface PullRequestPage extends Field<values.PullRequestPage> {
      items: ListField<values.PullRequest> &
        (() => ListField<values.PullRequest>);
      next: Scalar<PullRequestPage> & (() => Scalar<PullRequestPage>);
      /**
       * A reference to this node
       */
      gref: Scalar<PullRequestPage> & (() => Scalar<PullRequestPage>);
    }
    interface PullRequest extends Field<values.PullRequest> {
      /**
       * The unique identifier of the pull request
       */
      number: Scalar<number> & (() => Scalar<number>);
      /**
       * The title of the pull request
       */
      title: Scalar<string> & (() => Scalar<string>);
      /**
       * The identifier of the pull request
       */
      id: Scalar<number> & (() => Scalar<number>);
      /**
       * The state of the pull request
       */
      state: Scalar<string> & (() => Scalar<string>);
      /**
       * The body content of the pull request
       */
      body: Scalar<string> & (() => Scalar<string>);
      /**
       * Indicates if the pull request is locked
       */
      locked: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * Indicates if the pull request is merged
       */
      merged: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * The reason for the active lock on the pull request
       */
      active_lock_reason: Scalar<string> & (() => Scalar<string>);
      /**
       * The diff content of the pull request
       */
      diff: Scalar<string> & (() => Scalar<string>);
      /**
       * The node ID of the pull request
       */
      node_id: Scalar<string> & (() => Scalar<string>);
      /**
       * The owner of the pull request
       */
      owner: Scalar<User> & (() => Scalar<User>);
      /**
       * Collection of comments associated with the pull request
       */
      comments: CommentCollection & (() => CommentCollection);
      /**
       * The github.com URL of the Pull Request
       */
      html_url: Scalar<string> & (() => Scalar<string>);
      url: Scalar<string> & (() => Scalar<string>);
      pull_request_reviews: PullRequestReviewCollection &
        (() => PullRequestReviewCollection);
      requested_reviewers: RequestedReviewers & (() => RequestedReviewers);
      /**
       * A reference to this node
       */
      gref: Scalar<PullRequest> & (() => Scalar<PullRequest>);
      /**
       * Close the pull request
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      close: Action<void> & (() => Action<void>);
      /**
       * Create a new comment for the pull request
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      createComment: Action<void> & ((args: { body: string }) => Action<void>);
      merge: Action<void> &
        ((args?: {
          commit_title?: string;
          commit_message?: string;
          sha?: string;
          merge_method?: string;
        }) => Action<void>);
      /**
       * Triggered when the pull request is closed
       */
      closed: NodeEvent<boolean> & (() => NodeEvent<boolean>);
    }
    interface PullRequestEvent extends Field<values.PullRequestEvent> {
      pullRequest: Scalar<PullRequest> & (() => Scalar<PullRequest>);
      /**
       * A reference to this node
       */
      gref: Scalar<PullRequestEvent> & (() => Scalar<PullRequestEvent>);
    }
    interface PullRequestReviewCollection
      extends Field<values.PullRequestReviewCollection> {
      one: PullRequestReview & ((args: { id: string }) => PullRequestReview);
      page: PullRequestReviewPage &
        ((args?: {
          state?: string;
          head?: string;
          base?: string;
          sort?: string;
          order?: string;
          page?: number;
          pageSize?: number;
        }) => PullRequestReviewPage);
      /**
       * A reference to this node
       */
      gref: Scalar<PullRequestReviewCollection> &
        (() => Scalar<PullRequestReviewCollection>);
    }
    interface PullRequestReviewPage
      extends Field<values.PullRequestReviewPage> {
      items: ListField<values.PullRequestReview> &
        (() => ListField<values.PullRequestReview>);
      next: Scalar<PullRequestReviewPage> &
        (() => Scalar<PullRequestReviewPage>);
      /**
       * A reference to this node
       */
      gref: Scalar<PullRequestReviewPage> &
        (() => Scalar<PullRequestReviewPage>);
    }
    interface PullRequestReview extends Field<values.PullRequestReview> {
      /**
       * How the author is associated with the repository. Can be one of: COLLABORATOR, CONTRIBUTOR, FIRST_TIMER, FIRST_TIME_CONTRIBUTOR, MANNEQUIN, MEMBER, NONE, OWNER
       */
      author_association: Scalar<string> & (() => Scalar<string>);
      /**
       * The text of the review. Can be null.
       */
      body: Scalar<string> & (() => Scalar<string>);
      /**
       * A commit SHA for the review.
       */
      commit_id: Scalar<string> & (() => Scalar<string>);
      /**
       * The github.com URL of the review.
       */
      html_url: Scalar<string> & (() => Scalar<string>);
      /**
       * Unique identifier of the review.
       */
      id: Scalar<number> & (() => Scalar<number>);
      /**
       * The node identifier for the review.
       */
      node_id: Scalar<string> & (() => Scalar<string>);
      /**
       * The URL of the associated pull request.
       */
      pull_request_url: Scalar<string> & (() => Scalar<string>);
      /**
       * The state of the review.
       */
      state: Scalar<string> & (() => Scalar<string>);
      /**
       * The submission date of the review. Can be null.
       */
      submitted_at: Scalar<string> & (() => Scalar<string>);
      /**
       * The user who submitted the review. Can be null.
       */
      user: Scalar<User> & (() => Scalar<User>);
      /**
       * A reference to this node
       */
      gref: Scalar<PullRequestReview> & (() => Scalar<PullRequestReview>);
    }
    interface PullRequestReviewEvent
      extends Field<values.PullRequestReviewEvent> {
      pullRequestReview: Scalar<PullRequestReview> &
        (() => Scalar<PullRequestReview>);
      /**
       * A reference to this node
       */
      gref: Scalar<PullRequestReviewEvent> &
        (() => Scalar<PullRequestReviewEvent>);
    }
    interface RequestedReviewers extends Field<values.RequestedReviewers> {
      one: ReviewRequest & ((args: { name: string }) => ReviewRequest);
      page: ReviewRequestsPage & (() => ReviewRequestsPage);
      /**
       * A reference to this node
       */
      gref: Scalar<RequestedReviewers> & (() => Scalar<RequestedReviewers>);
    }
    interface ReviewRequestsPage extends Field<values.ReviewRequestsPage> {
      items: ListField<values.ReviewRequest> &
        (() => ListField<values.ReviewRequest>);
      next: Scalar<ReviewRequestsPage> & (() => Scalar<ReviewRequestsPage>);
      /**
       * A reference to this node
       */
      gref: Scalar<ReviewRequestsPage> & (() => Scalar<ReviewRequestsPage>);
    }
    interface ReviewRequest extends Field<values.ReviewRequest> {
      user: Scalar<User> & (() => Scalar<User>);
      time: Scalar<string> & (() => Scalar<string>);
      /**
       * A reference to this node
       */
      gref: Scalar<ReviewRequest> & (() => Scalar<ReviewRequest>);
    }
    interface ReviewRequestEvent extends Field<values.ReviewRequestEvent> {
      pullRequest: Scalar<PullRequest> & (() => Scalar<PullRequest>);
      requestedReviewer: Scalar<User> & (() => Scalar<User>);
      requester: Scalar<User> & (() => Scalar<User>);
      /**
       * A reference to this node
       */
      gref: Scalar<ReviewRequestEvent> & (() => Scalar<ReviewRequestEvent>);
    }
    interface CommentCollection extends Field<values.CommentCollection> {
      /**
       * Retrieve a single comment from the Github repository
       */
      one: Comment & ((args: { id: number }) => Comment);
      /**
       * Retrieve a page of comments from the Github repository
       */
      page: CommentPage &
        ((args?: { page?: number; pageSize?: number }) => CommentPage);
      /**
       * A reference to this node
       */
      gref: Scalar<CommentCollection> & (() => Scalar<CommentCollection>);
    }
    interface CommentPage extends Field<values.CommentPage> {
      /**
       * List of Comment items.
       */
      items: ListField<values.Comment> & (() => ListField<values.Comment>);
      /**
       * Reference to the next CommentPage.
       */
      next: Scalar<CommentPage> & (() => Scalar<CommentPage>);
      /**
       * A reference to this node
       */
      gref: Scalar<CommentPage> & (() => Scalar<CommentPage>);
    }
    interface Comment extends Field<values.Comment> {
      id: Scalar<number> & (() => Scalar<number>);
      /**
       * The content of the comment
       */
      body: Scalar<string> & (() => Scalar<string>);
      /**
       * The creation date of the comment
       */
      created_at: Scalar<string> & (() => Scalar<string>);
      /**
       * The date when the comment was last updated
       */
      updated_at: Scalar<string> & (() => Scalar<string>);
      /**
       * The user who commented
       */
      user: User & (() => User);
      /**
       * A github.com link/URL of the comment
       */
      html_url: Scalar<string> & (() => Scalar<string>);
      /**
       * API URL of the comment
       */
      url: Scalar<string> & (() => Scalar<string>);
      /**
       * API URL of the issue
       */
      issue_url: Scalar<string> & (() => Scalar<string>);
      node_id: Scalar<string> & (() => Scalar<string>);
      author_association: Scalar<string> & (() => Scalar<string>);
      /**
       * Emoji reactions to the comment
       */
      reactions: Reactions & (() => Reactions);
      /**
       * A slug identifying the app that generated the comment (e.g. vercel), if applicable
       */
      performed_via_github_app: Scalar<string> & (() => Scalar<string>);
      /**
       * A reference to this node
       */
      gref: Scalar<Comment> & (() => Scalar<Comment>);
    }
    interface CommentEvent extends Field<values.CommentEvent> {
      /**
       * Reference to the comment associated with the event
       */
      comment: Scalar<Comment> & (() => Scalar<Comment>);
      /**
       * A reference to this node
       */
      gref: Scalar<CommentEvent> & (() => Scalar<CommentEvent>);
    }
    interface ReleaseCollection extends Field<values.ReleaseCollection> {
      /**
       * Retrieves a single release by ID
       */
      one: Release & ((args: { id: string }) => Release);
      /**
       * Retrieves a page of releases
       */
      page: ReleasePage &
        ((args?: { pageSize?: string; page?: string }) => ReleasePage);
      /**
       * A reference to this node
       */
      gref: Scalar<ReleaseCollection> & (() => Scalar<ReleaseCollection>);
    }
    interface ReleasePage extends Field<values.ReleasePage> {
      items: ListField<values.Release> & (() => ListField<values.Release>);
      next: Scalar<ReleasePage> & (() => Scalar<ReleasePage>);
      /**
       * A reference to this node
       */
      gref: Scalar<ReleasePage> & (() => Scalar<ReleasePage>);
    }
    interface Release extends Field<values.Release> {
      /**
       * Unique identifier of the release
       */
      id: Scalar<number> & (() => Scalar<number>);
      /**
       * Name of the release
       */
      name: Scalar<string> & (() => Scalar<string>);
      /**
       * Description of the release
       */
      body: Scalar<string> & (() => Scalar<string>);
      /**
       * Indicates if the release is a draft
       */
      draft: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * Indicates if the release is a pre-release
       */
      prerelease: Scalar<boolean> & (() => Scalar<boolean>);
      /**
       * URL of the release
       */
      html_url: Scalar<string> & (() => Scalar<string>);
      /**
       * API URL of the release
       */
      url: Scalar<string> & (() => Scalar<string>);
      /**
       * Node ID of the release
       */
      node_id: Scalar<string> & (() => Scalar<string>);
      /**
       * Tag name of the release
       */
      tag_name: Scalar<string> & (() => Scalar<string>);
      /**
       * Target commitish of the release
       */
      target_commitish: Scalar<string> & (() => Scalar<string>);
      /**
       * Creation date of the release
       */
      created_at: Scalar<string> & (() => Scalar<string>);
      /**
       * A reference to this node
       */
      gref: Scalar<Release> & (() => Scalar<Release>);
    }
    interface ReleaseEvent extends Field<values.ReleaseEvent> {
      release: Scalar<Release> & (() => Scalar<Release>);
      /**
       * A reference to this node
       */
      gref: Scalar<ReleaseEvent> & (() => Scalar<ReleaseEvent>);
    }
    interface ContentCollection extends Field<values.ContentCollection> {
      /**
       * Field representing a single file from Github
       */
      file: Content & ((args?: { path?: string }) => Content);
      /**
       * Field representing a directory of files from Github
       */
      dir: ListField<values.Content> &
        ((args?: { path?: string }) => ListField<values.Content>);
      /**
       * A reference to this node
       */
      gref: Scalar<ContentCollection> & (() => Scalar<ContentCollection>);
    }
    interface Content extends Field<values.Content> {
      /**
       * The type of the file, directory, symlink, or submodule
       */
      type: Scalar<string> & (() => Scalar<string>);
      /**
       * The name of the file, directory, symlink, or submodule
       */
      name: Scalar<string> & (() => Scalar<string>);
      /**
       * The encoding type of the file content
       */
      encoding: Scalar<string> & (() => Scalar<string>);
      /**
       * The content of the file
       */
      content: Scalar<string> & (() => Scalar<string>);
      /**
       * The text content of the file
       */
      contentText: Scalar<string> & (() => Scalar<string>);
      /**
       * The path of the file, directory, symlink, or submodule
       */
      path: Scalar<string> & (() => Scalar<string>);
      /**
       * The SHA hash of the file
       */
      sha: Scalar<string> & (() => Scalar<string>);
      /**
       * The size of the file in bytes
       */
      size: Scalar<number> & (() => Scalar<number>);
      /**
       * The git URL of the submodule
       */
      submodule_git_url: Scalar<string> & (() => Scalar<string>);
      /**
       * The HTML URL of the file
       */
      html_url: Scalar<string> & (() => Scalar<string>);
      /**
       * The download URL of the file
       */
      download_url: Scalar<string> & (() => Scalar<string>);
      /**
       * A reference to this node
       */
      gref: Scalar<Content> & (() => Scalar<Content>);
      /**
       * Set the content of the file with an optional message
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      setContent: Action<void> &
        ((args: { content: string; message?: string }) => Action<void>);
      /**
       * Set the text content of the file with an optional message
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      setText: Action<void> &
        ((args: { text: string; message?: string }) => Action<void>);
    }
    interface GlobalSearch extends Field<values.GlobalSearch> {
      /**
       * Field for retrieving commit pages from the Github repository.
       */
      commits: CommitPage &
        ((args: {
          type?: string;
          sort?: string;
          order?: string;
          page?: number;
          pageSize?: number;
          q: string;
        }) => CommitPage);
      issues: IssuePage &
        ((args: {
          type?: string;
          sort?: string;
          order?: string;
          page?: number;
          pageSize?: number;
          q: string;
        }) => IssuePage);
      /**
       * Field for retrieving issue pages from the Github repository.
       */
      repos: RepositoryPage & ((args?: { sort?: string }) => RepositoryPage);
      /**
       * A reference to this node
       */
      gref: Scalar<GlobalSearch> & (() => Scalar<GlobalSearch>);
    }
    interface Tests extends Field<values.Tests> {
      /**
       * A reference to this node
       */
      gref: Scalar<Tests> & (() => Scalar<Tests>);
      /**
       * Test the functionality for the user action
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      testUser: Action<boolean> & (() => Action<boolean>);
      /**
       * Test the functionality for the repo action
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      testRepo: Action<boolean> & (() => Action<boolean>);
      /**
       * Test the functionality for the issue action
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      testIssue: Action<boolean> & (() => Action<boolean>);
      /**
       * Test the functionality for the commit action
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      testCommit: Action<boolean> & (() => Action<boolean>);
      /**
       * Test the functionality for the issue comment action
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      testIssueComment: Action<boolean> & (() => Action<boolean>);
      /**
       * Test the functionality for the pull request action
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      testPullRequest: Action<boolean> & (() => Action<boolean>);
      /**
       * Test the functionality for the search action
       *
       * Note: remember to `await` this action invocation. Or, chain another `Action` method: `.$invoke()`, `.$invokeAt()`, `.$invokeIn()`, `.$cron()`
       *
       * See: https://docs.membrane.io/reference/membrane-module#action
       */
      testSearch: Action<boolean> & (() => Action<boolean>);
    }
  }

  type Root = handles.Root;
  type UserCollection = handles.UserCollection;
  type UserPage = handles.UserPage;
  type User = handles.User;
  type OrganizationCollection = handles.OrganizationCollection;
  type OrganizationPage = handles.OrganizationPage;
  type Organization = handles.Organization;
  type RepositoryCollection = handles.RepositoryCollection;
  type RepositoryPage = handles.RepositoryPage;
  type Repository = handles.Repository;
  type PushEvent = handles.PushEvent;
  type License = handles.License;
  type LicenseDesc = handles.LicenseDesc;
  type BranchCollection = handles.BranchCollection;
  type BranchPage = handles.BranchPage;
  type Branch = handles.Branch;
  type CommitCollection = handles.CommitCollection;
  type CommitPage = handles.CommitPage;
  type Commit = handles.Commit;
  type Reactions = handles.Reactions;
  type IssueCollection = handles.IssueCollection;
  type IssueSearchPage = handles.IssueSearchPage;
  type IssuePage = handles.IssuePage;
  type Issue = handles.Issue;
  type IssueEvent = handles.IssueEvent;
  type Label = handles.Label;
  type PullRequestCollection = handles.PullRequestCollection;
  type PullRequestPage = handles.PullRequestPage;
  type PullRequest = handles.PullRequest;
  type PullRequestEvent = handles.PullRequestEvent;
  type PullRequestReviewCollection = handles.PullRequestReviewCollection;
  type PullRequestReviewPage = handles.PullRequestReviewPage;
  type PullRequestReview = handles.PullRequestReview;
  type PullRequestReviewEvent = handles.PullRequestReviewEvent;
  type RequestedReviewers = handles.RequestedReviewers;
  type ReviewRequestsPage = handles.ReviewRequestsPage;
  type ReviewRequest = handles.ReviewRequest;
  type ReviewRequestEvent = handles.ReviewRequestEvent;
  type CommentCollection = handles.CommentCollection;
  type CommentPage = handles.CommentPage;
  type Comment = handles.Comment;
  type CommentEvent = handles.CommentEvent;
  type ReleaseCollection = handles.ReleaseCollection;
  type ReleasePage = handles.ReleasePage;
  type Release = handles.Release;
  type ReleaseEvent = handles.ReleaseEvent;
  type ContentCollection = handles.ContentCollection;
  type Content = handles.Content;
  type GlobalSearch = handles.GlobalSearch;
  type Tests = handles.Tests;
}
declare module "membrane" {
  /**
   * Contains the graph references (grefs) that this program has been given access to.
   */
  export const nodes: {
    readonly user: github.User;
    readonly clock: Clock;
    readonly process: Process;
  };
  /**
   * A gref to the root of this program.
   */
  export const root: Root;
  /**
   * An object that can hold any data which transparently persists across program updates.
   * To give this object a type, export a type named `State` from your program's index.ts.
   * For example:
   * ```
   *   export type State = {
   *     birthdays: Record<string, Date>;
   *   }
   * ```
   * In Membrane you can use `state` to efficiently store any object that persist across
   * invocations and updates.
   *
   * Data stored in `state` doesn't necessarily have to be serializable, any JavaScript value can be kept in it,
   * including functions, promises, dates, etc.
   */
  export const state: State;
}
